//vim:set ft=c
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
precision mediump int;

uniform ivec2 window_size;
//left top width height
uniform int max_iterations;
uniform vec4 box;

const int max_max = 0xffffff;
const float fmax_max = float(max_max);

vec2 scale() {
  float left   = box[0];
  float top    = box[1];
  float width  = box[2];
  float height = box[3];
  float x = (gl_FragCoord.x / float(window_size.x)) * width + left;
  float y = (gl_FragCoord.y / float(window_size.y)) * height + top;
  return vec2(x,y);
}

vec2 c_square(vec2 c) {
  return vec2(
    pow(c.x, 2.) - pow(c.y, 2.),
    2. * c.x * c.y
  );
}

float c_magnitude(vec2 c) {
  return sqrt(pow(c.x, 2.) + pow(c.y, 2.));
}

float mandel(vec2 pt) {
  int iterations = 0;
  vec2 last = vec2(0.,0.);
  for(int i = 1; i <= max_max; i++) {
    last = c_square(last) + pt;
    iterations = i;
    if(i > max_iterations || c_magnitude(last) > 2.)
      break;
  }
  return float(iterations)/float(max_iterations);
}

// 1 << 16
const float bytes_2 = 65536.;

vec3 toColor(float f) {
  vec3 color;
  /* color.r = f; color.g = f; color.b = f; return color; */
  f *= fmax_max;
  color.r = floor(f / bytes_2);
  color.g = floor((f - color.r * bytes_2) / 256.0);
  color.b = floor(f - color.r * bytes_2 - color.g * 256.0);
  return color / 256.0;
}

void main() {
  float mandel = mandel(scale());
  gl_FragColor = vec4(toColor(mandel), 1);
}
